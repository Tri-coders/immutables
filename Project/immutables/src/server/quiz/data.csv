Timestamp,Question,Code,Question Type,Answers,A,B,C,D,Answer Explanation,Question Tag
11/02/20 19:24,Predict the output,"class Test {
int i;
}

class Main {
public static void main(String args[]) {
Test t;
System.out.println(t.i);
}
}",MCQ,C,0,garbage value,compiler error,runtime error,"t is just a reference, the object referred by t is not allocated any memory. Unlike C++, in Java all non-primitive objects must be explicitly allocated and these objects are allocated on heap. The following is corrected program. ",Classes and Objects
11/02/20 19:25,Predict the output,"class Test {
int i;
}

class Main {
public static void main(String args[]) {
Test t = new Test();
System.out.println(t.i);
}
}",MCQ,B,garbage aalue,0,compiler error,runtime error,"In Java, fields of classes and objects that do not have an explicit initializer and elements of arrays are automatically initialized with the default value for their type (false for boolean, 0 for all numerical types, null for all reference types). Local variables in Java must be definitely assigned to before they are accessed, or it is a compile error.",Classes and Objects
11/02/20 19:28,Predict the output,"class demo {
int a, b;

demo() {
a = 10;
b = 20;
}

public void print() {
System.out.println(""a = "" + a + "" b = "" + b);
}
}

class Test {

public static void main(String[] args) {
demo obj1 = new demo();
demo obj2 = obj1;

obj1.a += 1;
obj1.b += 1;

System.out.println(""values of obj1 : "");
obj1.print();
System.out.println(""values of obj2 : "");
obj2.print();

}
}",MCQ,B,compiler error,"values of obj1:
a = 11 b = 21
values of obj2:
a = 11 b = 21","values of obj1:
a = 11 b = 21
values of obj2:
a = 10 b = 20",runtime error,"Assignment of obj2 to obj1 makes obj2 a reference to obj1. Therefore, any change in obj1 will be reflected in obj2 also.",Classes and Objects
11/02/20 19:31,Predict the output,"class demoClass
{
int a = 1;

void func()
{
demo obj = new demo();
obj.display();
}


class demo
{
int b = 2;

void display()
{
System.out.println(""na = "" + a);
}
}

void get()
{
System.out.println(""nb = "" + b);
}
}


class Test
{
public static void main(String[] args)
{
demoClass obj = new demoClass();
obj.func();
obj.get();

}
}",MCQ,B,"a = 1
b = 2",compilation error,"b = 2
a = 1",runtime error,"Members of inner class ‘demo’ can not be used in the outer class ‘Test’. Thus, get() of outer class can not access variable ‘b’ of inner class.",Classes and Objects
11/02/20 20:46,Predict the output,"class First {

void display() {
System.out.println(""Inside First"");
}
}

class Second extends First {

void display() {
System.out.println(""Inside Second"");
}
}

class Test {

public static void main(String[] args) {
First obj1 = new First();
Second obj2 = new Second();

First ref;
ref = obj1;
ref.display();

ref = obj2;
ref.display();
}
}",MCQ,B,compilation error,"Inside First
Inside Second","Inside First
Inside First",Runtime error,‘ref’ is a reference variable which obtains the reference of object of class First and calls its function display(). Then ‘ref’ refers to object of class Second and calls its function display(). ,Polymorphism
11/02/20 22:45,Predict the output,"class Test {
public static void main(String[] args) {
Test obj = new Test();
obj.start();
}
void start() {
String stra = ""do"";
String strb = method(stra);
System.out.print("" : ""+stra + strb);
}
String method(String stra) {
stra = stra + ""good"";
System.out.print(stra);
return ""good"";
}
}",MCQ,D,dogood : dogoodgood,dogood : gooddogood,dogood : dodogood,dogood : dogood,,Classes Methods
11/02/20 22:47,Predict the output,"class Test {
int a = 1;
int b = 2;

Test func(Test obj) {
Test obj3 = new Test();
obj3 = obj;
obj3.a = obj.a++ + ++obj.b;
obj.b = obj.b;
return obj3;
}

public static void main(String[] args) {
Test obj1 = new Test();
Test obj2 = obj1.func(obj1);

System.out.println(""obj1.a = "" + obj1.a + "" obj1.b = "" + obj1.b);
System.out.println(""obj2.a = "" + obj2.a + "" obj1.b = "" + obj2.b);

}
}",MCQ,B,"obj1.a = 1 obj1.b = 2
obj2.a = 4 obj2.b = 3","obj1.a = 4 obj1.b = 3
obj2.a = 4 obj2.b = 3",compilation error,runtime error,,Classes and Objects
11/02/20 22:50,"In Java, when we implement an interface method, it must be declared as:",,MCQ,C,Private,Protected,Public,Friend,"In Java, when we implement an interface method, it must be declared as Public.",Interface
11/02/20 23:06,Predict the output,"class A {
int i = 10;
}

class B extends A {
int i = 20;
}

public class Test {
public static void main(String[] args) {
A a = new B();

System.out.println(a.i);
}
}",MCQ,D,compilation error,20,runtime error,10,,Polymorphism
11/02/20 23:11,A Class can extend itself.,,True or False,FALSE,TRUE,FALSE,,,,Inheritance
11/02/20 23:18,Predict the output,"class A {
public A() {
System.out.println(""Class A Constructor"");
}
}

class B extends A {
public B() {
System.out.println(""Class B Constructor"");
}
}

class C extends B {
public C() {
System.out.println(""Class C Constructor"");
}
}

public class Test {
public static void main(String[] args) {
C c = new C();
}
}",MCQ,D,"Class C Constructor
Class B Constructor
Class A Constructor","Class C Constructor
Class C Constructor
Class C Constructor","Class A Constructor
Class A Constructor
Class A Constructor","Class A Constructor
Class B Constructor
Class C Constructor",,Constructor
11/02/20 23:25,Private members of a class are inherited to sub class.,,True or False,FALSE,TRUE,FALSE,,,,Inheritance
11/02/20 23:28,Predict the output,"class X {
static void staticMethod() {
System.out.println(""Class X"");
}
}

class Y extends X {
static void staticMethod() {
System.out.println(""Class Y"");
}
}

public class Test {
public static void main(String[] args) {
Y.staticMethod();
}
}",MCQ,B,compilation error,Class Y,runtime error,syntax error,,Inheritance
11/03/20 21:52,Which of the following is true about Static Initialization Block?,,MCQ,D,We can use only static members of a class inside the Static Initialization Block.,Static Initialization Blocks are mainly used to initialize static fields of a class.,Static Initialization Block is the first block to be executed after class is loaded in the memory.,All of the above.,"Static Initialization Blocks are the first blocks to be executed after class is loaded in the memory. These blocks are mainly used to initialize static fields of a class. Inside a static initialization block, we can use only static members of a class.",Initialization Block
11/03/20 21:53,Static initialization blocks are stored in the memory,,True or False,FALSE,TRUE,FALSE,,,"Static Initialization Blocks are not at all stored in the memory. They just come to stack, execute their task and leave the memory.",Initialization Block
11/03/20 22:02,Predict the output,"class A {
static int i;
static {
System.out.println(1);
i = 100;
}
}

public class Test {
static {
System.out.println(2);
}

public static void main(String[] args) {
System.out.println(3);

System.out.println(A.i);
}
}",MCQ,B,"1
2
3
100","2
3
1
100","3
2
1
100",Compile time error,,Initialization Block
11/03/20 22:05,Predict the output,"class Test {
int i;

static {
System.out.println(i);
}
}",MCQ,C,runtime error,0,compile time error,garbage value,"Because, you can’t refer a non static field inside a static initialization block.",Initialization Block
11/03/20 22:07,The below code is written correctly,"class A {
static
{
static
{
System.out.println(1);
}
}
}",True or False,FALSE,TRUE,FALSE,,,,Initialization Block
11/03/20 22:09,How many static initialization blocks are there in the below Class A?,"class A {
static int a = 50;

static {
a = 50;
}

static {
a = 50;
}
}",MCQ,D,0,1,2,3,"class A {
static int a = 50; // ----- (1)

static {
a = 50; // ----- (2)
}

static {
a = 50; // ----- (3)
}
}",Initialization Block
11/03/20 22:19,Predict the output,"public class Test {
static {
System.out.println(1);
}

static {
System.out.println(2);
}

static {
System.out.println(3);
}

public static void main(String[] args) {
Test test;
}
}",MCQ,B,"3
2
1","1
2
3",garbage value,compile time error,,Initialization Block
11/03/20 22:33,Predict the output,"class A {
static int first;

static String second;

static {
System.out.println(1);

first = 100;
}

static {
System.out.println(2);

second = ""SECOND"";
}
}

public class Test {
static {
System.out.println(3);
}

public static void main(String[] args) {
System.out.println(4);

System.out.println(A.first);

System.out.println(A.second);
}
}",MCQ,C,"3
4
1
2
0
null","4
3
2
1
100
SECOND","3
4
1
2
100
SECOND","4
3
2
1
0
null",,Initialization Block
11/03/20 22:58,Predict the output,"class A {
static int i;

static {
i = 100;

System.out.println(1);
}

static void staticMethod() {
System.out.println(i);

System.out.println(2);
}
}

public class Test {
static {
System.out.println(3);
}

public static void main(String[] args) {
System.out.println(4);

System.out.println(A.i);

A.staticMethod();
}
}",MCQ,A,"3
4
1
100
100
2","3
4
1
100
2","3
4
1
100
1
100
2","3
4
1
100
2
100
2",,Initialization Block
11/03/20 23:01,We can invoke static method inside the SIB – Static Initialization Block,,True or False,TRUE,TRUE,FALSE,,,"Yes, We can invoke static method inside the SIB.

e.g.
class Test {
// SIB - Static Initialization Block
static {
staticmethod(); // Invoking static method inside SIB
}

static void staticmethod() {
System.out.println(""It is a static method"");
}
}",Initialization Block
11/03/20 23:05,Predict the output,"class Test {
{
System.out.println(1);
}

public Test() {
System.out.println(2);
}

public static void main(String[] args) {
System.out.println(3);

Test a = new Test();
}
}",MCQ,B,"1
2
3","3
1
2","3
2
1",compile time error,The initialisation block in this question is Instance Initialisation Block and we know that the instance initialisation block gets copied into constructor and then it gets executed.,Initialization Block
11/03/20 23:11,Predict the output,"public class Test {
{
System.out.println(""First"");
}

{
System.out.println(""Second"");
}

{
System.out.println(""Third"");
}

public Test() {
System.out.println(""Fourth"");
}

public static void main(String[] args) {
System.out.println(""Fifth"");

Test a = new Test();
}
}",MCQ,C,"First
Second
Third
Fourth
Fifth","Fifth
Fourth
Third
Second
First","Fifth
First
Second
Third
Fourth",compile time error,,Initialization Block
11/03/20 23:16,"Which one of these are executed first while creating an object to the class?

i) Statements of IIB (Instance Initialisation Block) block
ii) Statements of constructor",,MCQ,A,only i),only ii),both i) and ii) simultaneously,neither i) nor ii),"In any constructor, first statement will be either super() or this(). Second set of statements will be calling statements to all IIB’s of the class and third set of statements will be actual statements of constructor. Here is the template of a constructor.

Constructor()
{
[ (super() or this() ]

[ Calling Statements to IIB's ]

[ Statements of constructor ]
}",Initialization Block
11/03/20 23:22,Predict the output,"public class Test {
int i;

{
System.out.println(""IIB-1"");

i = 100;
}

{
System.out.println(""IIB-2"");

System.out.println(i);

i = 200;
}

public static void main(String[] args) {
System.out.println(""main"");

Test a = new Test();

System.out.println(a.i);
}
}",MCQ,D,"main
IIB-1
IIB-2
100
IIB-1
IIB-2
100
200","main
0","main
200","main
IIB-1
IIB-2
100
200",,Initialization Block
11/03/20 23:24,we can use static fields of a class inside the instance initialization block (IIB),,True or False,TRUE,TRUE,FALSE,,,"Yes, we can use static fields inside the IIB.

e.g.
public class Test {
static int staticField = 10; // Static Field

// Instance Initialization Block - IIB

{
// using static field inside IIB

System.out.println(staticField);
}
}",Initialization Block
11/03/20 23:32,"Does below program run successfully? if yes, what will be the output?","public class Test {
static int i = 10;

int j = 100;

{
methodOne();

i = 100;

j = 10;
}

void methodOne() {
System.out.println(""i = "" + i);

System.out.println(""j = "" + j);
}

public static void main(String[] args) {
Test a = new Test();

a.methodOne();
}
}",MCQ,A,"Yes, program will run successfully. Output will be,
i = 10
j = 100
i = 100
j = 10","No, program will not run successfully","Yes, program will run successfully. Output will be,
i = 10
j = 100","Yes, program will run successfully. Output will be,
i = 10
j = 100
i = 10
j = 100",,Initialization Block
11/03/20 23:46,Predict the output,"public class Test
{
{
System.out.println(1);
}

static
{
System.out.println(2);
}

public Test()
{
System.out.println(3);
}

public static void main(String[] args)
{
System.out.println(4);

Test a = new Test();
}
}",MCQ,C,"1
2
3
4","4
1
2
3","2
4
1
3","4
1
3
2","Static Block gets called at compile time and hence executed first. Instance block also gets added at start of constructor, but does not gets execute. The printed 4 at run time. After that when we create instance of class. The constructors gets called (which executes instance block first and then constructor statements)",Initialization Block
11/03/20 23:49,How many instance initializers (IIB) are there in the below class?,"public class Test {
char c = 'A';

{
c = 'B';
}

{
c = 'C';
}
}",MCQ,B,2,3,1,0,"Three.

public class Test {
char c = 'A'; // ------&gt; (1)

{
c = 'B'; // ------&gt; (2)
}

{
c = 'C'; // ------&gt; (3)
}
}",Initialization Block
11/04/20 00:02,Predict the output,"public class Test {
static {
i = 30;
}

static int i = 20;

static {
i = 10;
}

public static void main(String[] args) {
System.out.println(Test.i);
}
}",MCQ,C,20,"compile time error. variable ""i"" is not declared.",10,30,,Initialization Block
11/04/20 00:10,"Is the below code written correctly? If yes, what will be the output when you run it?","public class Test {
{
System.out.println(1);

id = 1001;
}

static {
System.out.println(2);

name = ""NAME"";
}

static String name;

public Test(String name, int id) {
System.out.println(3);

this.name = name;

this.id = id;
}

int id;

{
System.out.println(4);

System.out.println(id);
}

static {
System.out.println(5);

System.out.println(name);
}

public static void main(String[] args) {
System.out.println(6);

Test a = new Test(""MyName"", 1111);
}
}",MCQ,D,"Yes, code is written correctly. Output will be,
6
2
5
NAME
1
4
1001
3","Yes, code is written correctly. Output will be,
2
5
MyName
6
1
4
1111
3",No. The code will give compile time error,"Yes, code is written correctly. Output will be,
2
5
NAME
6
1
4
1001
3",Static Block gets executed at compile time. While instance block gets executed at runtime before constructor statements.,Initialization Block
11/04/20 00:23,Predict the output,"public class Test {
{
System.out.println(i);
}

int i = 10;

public static void main(String[] args) {
System.out.println(6);
}
}",MCQ,C,"10
6","6
10",compile time error,runtime error,Because you can't use a field before it is defined (even in initialization block),Classes and Objects
11/04/20 00:25,“Constructors must not have return type”. It is a rule in java. What happens if we mention return type for a constructor?,,MCQ,B,compile time error,It will be treated as a method with a warning that “this method has a constructor name”.,runtime error,syntax error,,Constructor
11/04/20 00:27,Below code is written correctly:,"public class Test {
{
i = 1111;
}

int i;

public static void main(String[] args) {
System.out.println(6);
}
}",True or False,TRUE,TRUE,FALSE,,,"You can’t use a field before it is defined. But, you can initialize a field before it is defined.",Initialization Block
11/04/20 00:29,"You know that if you don’t write any constructors in your class, compiler will keep one default constructor in your class. What will be the visibility of this default constructor?",,MCQ,D,default,private,protected,public,,Constructor
11/04/20 00:33,You can instantiate the below class in another class (Using new operator only),"public class Test {
private Test() {
System.out.println(""It is a constructor"");
}
}",True or False,FALSE,TRUE,FALSE,,,Because it has only private constructor.,Constructor
11/04/20 00:35,We can define constructors without a body,,True or False,FALSE,TRUE,FALSE,,,Constructors must be concrete.,Constructor
11/04/20 00:37,The below code will compile successfully,"public class Test {
final Test()
{
System.out.println(""It is a constructor"");
}

public static void main(String[] args) {
System.out.println(6);
}
}",True or False,FALSE,TRUE,FALSE,,,"Constructors can’t be final. They can either be public, protected or private.",Constructor
11/07/20 12:29,Predict the output,"class ClassOne {
static int i = 10;

static {
i = 20;
}

public ClassOne(int i) {
System.out.println(i);

this.i = i;
}

{
i = 30;
}
}

public class Test {
public static void main(String[] args) {
System.out.println(ClassOne.i);
}
}",MCQ,B,10,20,30,compile time error,"The static block gets executed at the compile time. Hence value of I is set to 20. The instance initializer block gets copied at start of constructor at compile time. 
But the parametrized constructor didn't get call (as we didn't pass any parameter while creating object of class). And hence the value of i remain to 20 only. Thus answer is 20.",Initialization Block
11/07/20 12:39,Predict the output,"class ClassOne {
{
System.out.println(1);
}

static {
System.out.println(2);
}

public ClassOne(int i) {
System.out.println(3);
}

public ClassOne() {
System.out.println(4);
}
}

public class Test {
{
System.out.println(5);
}

public static void main(String[] args) {
System.out.println(6);

ClassOne one = new ClassOne();

ClassOne two = new ClassOne(10);
}
}",MCQ,C,"6
5
2
1
4
1
3","6
5
1
2
3
4","6
2
1
4
1
3","6
2
1
4
2
1
3","Instance block of ClassTwo never gets called (as we didn't create object of ClassTwo in main function). The static block of ClassOne gets executed only once (even though object is created twice). Now for each object of ClassOne, respective constructor gets called (along with instance block.... each time).",Initialization Block
11/07/20 12:42,We can invoke one constructor from another constructor of the same class,,True or False,TRUE,TRUE,FALSE,,,"Yes. we can invoke one constructor from another constructor of the same class using ""this"" keyword.",Constructor
11/07/20 13:03,Predict the output,"class ClassOne {
char c = 'A';

{
c = 'B';
}

public ClassOne(char c) {
this.c = c;
}
}

public class Test {
public static void main(String[] args) {
ClassOne one = new ClassOne('D');

System.out.println(one.c);
}
}",MCQ,D,A,B,compile time error,D,"Instance block gets copied into constructor. But ""this"" keywords refers to the class variable, hence updating the class variable ""c"" with value ""D"" (passed as argument while object creation)",Constructor
11/07/20 13:07,Predict the output,"class ClassOne {
String s;

{
s = ""FIRST"";
}

{
s = ""SECOND"";
}

public ClassOne() {
s = ""THIRD"";
}

public ClassOne(String s) {
this();

System.out.println(this.s);
}
}

public class Test {
public static void main(String[] args) {
ClassOne one = new ClassOne(""LAST"");
}
}",MCQ,A,THIRD,FIRST,LAST,SECOND,"""this"" keywords calls the non-parameterized constructor into parametrized constructor. Hence ""this.s"" refers to variable ""s"" defined in non paremeterized constructor (and does not refer to variable ""s"" passed as argument while object creation).",Constructor
11/07/20 13:14,Below class is defined correctly.,"public class Test {
public Test(int i) {
this((float) 23.5);
}

public Test(float f) {
this(28.56);
}

Test(double d) {
this(10);
}

public static void main(String[] args) {
Test one = new Test(3);
}
}",True or False,FALSE,TRUE,FALSE,,,This code will throw compile time error. As Constructors can't be called recursively.,Constructor
11/07/20 13:15,How many constructors are there in below class?,"public class A
{

}",MCQ,B,0,1,2,infinite,"If you are not writing any constructors in your class, compiler will keep one No-arg constructor by default.",Constructor
11/07/20 13:18,Default constructor is always a no-argument constructor,,True or False,TRUE,TRUE,FALSE,,,Default constructor is a constructor implicitly written by the compiler if a class does not have any constructors. Default constructor is always a No-arg constructor.,Constructor
11/07/20 13:25,Predict the output,"import java.util.TreeSet;

public class Test {
static {
System.out.println('A');
}

static {
System.out.println('B');
}

public Test() {
System.out.println('C');
}

public static void main(String[] args) {
System.out.println('D');

Test a = new Test();
}
}",MCQ,C,"D
A
B
C","A
B
C
D","A
B
D
C","D
C
B
A","Static Block gets executed at compile time as per their order in code. At runtime, main function gets executed first and during object creation, constructor gets called.",Constructor
11/07/20 13:27,We can refer static fields in non-static methods. True or false?,,True or False,TRUE,TRUE,FALSE,,,We can refer static fields in non-static methods.,Classes Methods
11/07/20 13:38,We can give a call to non-static method from a static method,,True or False,FALSE,TRUE,FALSE,,,"We can’t call non-static method from a static method.

public class Test {
static void staticMethod() {
nonStaticMethod(); // Compile time error : can't make static reference to non-static method
}

void nonStaticMethod() {

}
}",Classes Methods
11/07/20 18:14,Which of the following is common to all instances of a class?,,MCQ,A,Static fields,Non-static methods,Static methods,A & C,,Classes and Objects
11/07/20 18:22,The below code will give output. True or False?,"public class Test {
static void methodOne() {
System.out.println(""A"");
}

void methodTwo() {
System.out.println(""B"");

methodOne();
}

public static void main(String[] args) {
System.out.println(""C"");

new Test().methodTwo();
}
}",True or False,TRUE,TRUE,False. Because Object of class Test is not assigned t any variable,,,"Even though the object of class Test is not assigned to any variable. We can still directly call the method of the object.

Output will be,
C
B
A",Classes and Objects
11/07/20 18:32,Predict the output,"class ClassOne {
static {
System.out.println(1);
}

public static void main(String[] args) {
System.out.println(2);
}
}

public class Test {
{
System.out.println(3);
}

public static void main(String[] args) {
ClassOne.main(args);
}
}",MCQ,B,"1
2
3","1
2","3
1
2",compile time error. Because one file can't contain 2 main methods.,java program can contain more than one methods. and the instance block of ClassTwo didn't get call (because object of ClassTwo was never created). Hence only static block and main methods gets executed of ClassOne.,Classes and Objects
11/08/20 12:26,Predict the output,"public class Test {
static int methodOne(int i) {
i = i++ + --i;

return i;
}

static int methodTwo(int i) {
i = i-- - ++i + methodOne(i);

return i;
}

public static void main(String[] args) {
int i = 11;

System.out.println(methodTwo(i) + ++i - --i);
}
}",MCQ,D,22,21,24,23,,Classes Methods
11/08/20 12:31,Predict the output,"class ClassOne {
static {
System.out.println('A');
}

static char c = 'Z';

static char getC() {
return c;
}
}

public class Test {
{
System.out.println('B');
}

public static void main(String[] args) {
char c;

c = ClassOne.getC();

System.out.println(c);
}
}",MCQ,A,"A
Z","B
A
Z","A
B
Z","A
Z
B","Instance block of ClassTwo never gets executed (Because we didn't create object of ClassTwo in main method). At compile time static block of ClassOne gets executed. After that variable ""c"" gets initialized with value ""Z"" and ""getC()"" returns value of variable c.",Initialization Block
11/08/20 12:41,Predict the output,"class ClassOne {
{
s = ""second"";
}

String s = ""first"";

{
System.out.println(s);

s = ""third"";
}

public ClassOne() {
System.out.println(s);
}

public ClassOne(String s) {
System.out.println(s);

this.s = s;
}
}

public class Test {
public static void main(String[] args) {
ClassOne one = new ClassOne(""last"");

ClassOne two = new ClassOne();
}
}",MCQ,B,"second
last
first
third","first
last
first
third","compile time error. Because variable ""s"" in not defined in first instance block of ClassOne.","second
last
second
third",,Initialization Block
11/08/20 12:43,"We can use ""this"" keyword in static context",,True or False,FALSE,TRUE,FALSE,,,,Classes and Objects
11/08/20 12:53,Predict the output,"public class Test {
static int i = 10, j = 20;

int m = 30, n = 40;

public static void main(String[] args) {
Test a1 = new Test();

Test a2 = new Test();

a1.i = 100;

System.out.println(a2.i);

a2.j = 200;

System.out.println(a1.j);

a1.m = 300;

System.out.println(a2.m);

a2.n = 400;

System.out.println(a1.n);
}
}",MCQ,C,"10
20
30
40","10
20
300
400","100
200
30
40","100
200
300
400","Static variable shares the same value among all instance of class (i.e. If one instance of class updates value of static variable. The value gets reflected in all instances).
Non-static variable are created separately for each instance of class (i.e. if one instance of class updates value of non-static variable. Then value of that variable in other instances of class doesn't get affected.)",Classes and Objects
11/08/20 13:05,Predict the output,"public class Test {
int i = 111;

static int j = 222;

static void methodOne(int i, int j) {
System.out.println(i);

System.out.println(j);
}

public static void main(String[] args) {
methodOne(333, 444);
}
}",MCQ,D,"111
222","111
444","333
222","333
444",,Classes and Objects
11/08/20 13:07,Super() is used to call constructor of the same class. True or False?,,True or False,FALSE,TRUE,FALSE,,,super() is used to call constructor of the super class where as this() is used to call constructor of the same class.,Classes and Objects
11/08/20 13:09,"Constructor signature consist of which of the below things:

1) Constructor name
2) Number of arguments
3) Types of arguments
4) Order of arguments",,MCQ,A,"1), 2), 3) and 4)","1), 3) and 4)","1), 2) and 3)",1) and 3),,Constructor
11/08/20 13:24,Predict the output,"public class Test {
int m;

double n;

public Test(int i) {
m = i;
}

public Test(double d) {
n = d;
}

{
System.out.println(m);

System.out.println(n);
}

public static void main(String[] args) {
Test a1 = new Test(500);

Test a2 = new Test(50.0);

System.out.println(a1.m + "" : "" + a1.n);

System.out.println(a2.m + "" : "" + a2.n);
}
}",MCQ,C,"500
50.0
500
50.0
500 : 50.0
500 : 50.0","500
50.0
0
0.0
500 : 0.0
0 : 50.0","0
0.0
0
0.0
500 : 0.0
0 : 50.0","500
50.0
500
50.0
500 : 0.0
0 : 50.0","During each object creation the instance block gets called. Hence instance block gets called twice (because 2 objects created in main method). 

But the variables were not initialized with any value (at the time of execution of instance block). Hence default values got printed.

After this as we can see object a1 assigned value to only m and object a2 assigned value to only n. Hence values of other variable in each object remain default.",Initialization Block
11/08/20 14:07,Predict the output,"public class Test {
char c = 'A';

Test a;

{
System.out.println(c);

c = 'B';
}

public Test(Test a) {
this.a = a;
}

public static void main(String[] args) {
Test a = null;

a = new Test(a);

System.out.println(a.c);

System.out.println(a.a.c);

System.out.println(a.a.a.c);

System.out.println(a.a.a.a.c);

a.a.a.a.a.c = 'Z';

System.out.println(a.c);
}
}",MCQ,B,"A
B
B
B
B
B
Z",Null pointer exception at runtime.,"A
B
A
A
A
A
Z",compile time error,"we will get null pointer exception at line ""System.out.println(a.a.c);""",Classes and Objects
11/08/20 14:14,Predict the output,"public class Test {
int i;

Test a;

{
i = 10;

a = new Test();
}

public static void main(String[] args) {
Test a = new Test();

System.out.println(a.a.a.a.a.a.i);
}
}",MCQ,D,10,compile time error,null pointer exception at runtime,StackOverflow error at runtime,"Instance block gets executed (through constructors) when object of class is created. But inside the instance block we are creating object of same class again.

So it will give stack overflow error at runtime. Because, constructor of class A will be kept calling",Initialization Block
11/08/20 14:17,Predict the output,"public class Test {
String s;

Test a;

public Test(String s) {
this.s = s;
}

public static void main(String[] args) {
Test a1 = new Test(""first"");

Test a2 = new Test(""second"");

a1.a = a2;

a2.a = a1;

System.out.println(a1.a.s);

System.out.println(a2.a.s);
}
}",MCQ,B,"first
second","second
first",compile time error,runtime error,,Classes and Objects
11/08/20 14:23,Predict the output,"public class Test {
String s;

public Test() {
this(""It's not me"");

System.out.println('A');

System.out.println(s);
}

Test(String s) {
System.out.println('B');

System.out.println(this.s);

this.s = s;
}

{
System.out.println('C');

System.out.println(s);

this.s = ""ABCD"";
}

public static void main(String[] args) {
Test a1 = new Test();

Test a2 = new Test(""It's me"");
}
}",MCQ,C,"C
null
B
It's not me
A
ABCD
C
null
B
ABCD","C
null
B
It's not me
A
ABCD
C
null
B
It's me","C
null
B
ABCD
A
It’s not me
C
null
B
ABCD","C
null
B
ABCD
A
It’s not me
C
null
B
It's me",,Classes and Objects
11/08/20 14:29,Predict the output,"public class Test {
static void A(int i) {
System.out.println(""Tested "" + i);
}

static {
A(5);
}

public static void main(String[] args) {
A(4);
}
}",MCQ,D,"Tested 4
Tested 5",compile time error,runtime error,"Tested 5
Tested 4",,Initialization Block
11/08/20 14:32,Predict the output,"class X {
int i = 50;
}

class Y {
int i = 100;

X x;
}

public class Test {
public static void main(String[] args) {
X x = new X();

Y y = new Y();

y.x = x;

System.out.println(x.i);

System.out.println(y.i);

System.out.println(y.x.i);
}
}",MCQ,D,"50
100
100",runtime error,compile time error,"50
100
50",,Classes and Objects
11/08/20 14:34,What are the modifiers allowed to apply to a constructor?,,MCQ,B,"default, public, private and protected","public, private and protected","default, public and protected","default, public and private",,Constructor
11/08/20 14:35,We can instantiate the below class. True or False?,"class X
{
X x = new X();
}",True or False,FALSE,TRUE,FALSE,,,"Constructor will be called recursively, thus throwing StackOverflowError.",Constructor
11/08/20 14:38,What will be the outcome of the below program?,"class X {
Z z = new Z();
}

class Y {
X x = new X();
}

class Z {
Y y = new Y();
}

public class Test {
public static void main(String[] args) {
Z z = new Z();
}
}",MCQ,B,compile time error,stack overflow error at runtime,null pointer exception error at runtime,No error & no output (because of no print statements),Exception in thread “main” java.lang.StackOverflowError. Constructors of all three classes are recursively called while you try to create an object to any class.,Constructor
11/08/20 14:39,We can call super() and this() from a method. True or False?,,True or False,FALSE,TRUE,FALSE,,,,Classes Methods
12/26/2020 22:44:52,How many maximum numbers of objects can be created from a single Class in Java?,,MCQ,A,32,64,256,None,There is no limit on the number of objects being created from a class.,Classes and Objects
12/26/2020 22:47:00,Creating an object from a class is also called ____.,,MCQ,B,Initializing,Instantiating,Interfacing,None of the above,,Classes and Objects
12/26/2020 22:48:16,An object is created at __ time in Java.,,MCQ,C,Compile-time,Assembling time,Run time,None of the above,,Classes and Objects
12/26/2020 22:53:34,Predict the output,"public class Example {

}

public class Test {
public static void main(String[] args) {
System.out.println(""Hello Boss.!"");
}
}",MCQ,D,Hello Boss.!,No Output,None of the above,Compiler error,There can not be more than one public class declared inside a single java file.,Classes and Objects
12/26/2020 23:12:56,Predict the output,"class Food {
int items;

int show() {
return items;
}
}

class Test {
public static void main(String[] args) {
Food f = new Food();
f.items = 5;
System.out.println(""Items Before = "" + f.show());
change(f);
System.out.println(""Items After = "" + f.show());
}

static void change(Food foo) {
foo.items = 10;
}
}",MCQ,A,"Items Before = 5
Items After = 10","Items Before = 10
Items After = 10","Items Before = 5
Items After = 5","Items Before = 10
Items After = 5",,Classes and Objects
12/26/2020 23:15:50,Predict the output,"class Test {
int rats = 5;

public static void main(String[] args) {
Test t1 = new Test();
System.out.println(""Rats Before = "" + t1.rats);
modify(t1.rats);
System.out.println(""Rats After = "" + t1.rats);
}

static void modify(int r) {
r = 20;
}
}",MCQ,B,"Rats Before = 5
Rats After = 20","Rats Before = 5
Rats After = 5","Rats Before = 20
Rats After = 20","Rats Before = 20
Rats After = 5","The primitive values are passed by value only. So, changes in the method modify does not change the original value.",Classes and Objects
12/26/2020 23:19:33,Predict the output,"class Cricket {
int runs;
}

class Test {
public static void main(String[] args) {
Cricket c1 = new Cricket();
c1.runs = 250;
Cricket c2;
c2 = c1;
c2.runs = 300;
System.out.println(""Runs= "" + c1.runs);
}
}",MCQ,C,Runs= 0,Runs= 250,Runs= 300,Compiler error,The reference C2 also points to the same object pointed by reference C1.,Classes and Objects
12/26/2020 23:21:37,Predict the output,"class Wordpress {
int posts;
}

class Test {
public static void main(String[] args) {
Wordpress wp1 = new Wordpress();
wp1.posts = 25;
Wordpress wp2 = wp1;
wp1 = null;
System.out.println(""Posts="" + wp2.posts);
}
}",MCQ,D,Posts=0,Posts=null,Runtime exception occurs,Posts=25,"Even if one REFERENCE to the same object is alive, it can be used to access the object. So, wp2 still works even if wp1 is set to null.",Classes and Objects
12/26/2020 23:24:50,"In Java, add a ___ to a constructor to convert it into a method.",,MCQ,A,return type,static,if statement,semicolon,Constructor does not have any return type in Java.,Constructor
12/26/2020 23:27:57,Predict the output,"public class Test {
void show() {
System.out.println(""SHOW Method.."");
return;
}

public static void main(String[] args) {
Test t2 = new Test();
t2.show();
}
}",MCQ,C,No output,Compiler error,SHOW Method..,None,A void method can use an empty return statement.,Classes Methods
12/27/2020 19:35:19,"A ""this"" operator used inside a Java method refers to ___ variable.",,MCQ,C,Global variable,Method local variable,Instance variable,None,,Classes Methods
12/27/2020 19:38:23,Predict the output.,"public class Test {
int cakes = 5;

void order(int cakes) {
this.cakes = cakes;
}

public static void main(String[] args) {
Test t4 = new Test();
t4.order(10);
System.out.println(""CAKES="" + t4.cakes);
}
}",MCQ,C,CAKES=5,CAKES=0,CAKES=10,Compiler error,"In the program, this.cakes refers to the instance variable cakes.",Classes Methods
12/27/2020 19:39:56,A local variable declared inside a method can not be used in expressions without initializing it first.,,True or False,TRUE,TRUE,FALSE,,,,Classes Methods
12/27/2020 19:42:13,Predict the output.,"public class Test {
public static void main(String[] args) {
int localVariable;
System.out.println(localVariable);
}
}",MCQ,D,0,garbage value,NullPointerException,Compiler error,"In the above program, the localVariable is a Local variable and it is not initialized. You can not use it in any expressions, not even printing.",Classes and Objects
12/27/2020 19:43:49,A static-method or a static-variable is shared among all instances of a class.,,True or False,TRUE,TRUE,FALSE,,,Yes. a single copy of a static variable or method is common to all instance objects.,Classes Methods
12/27/2020 19:47:53,Predict the output,"public class Test {
static int cats = 25;

public static void main(String[] args) {
Test t6 = new Test();
System.out.println(""t6 BIRDS before="" + t6.cats);
Test t7 = new Test();
t7.cats = 10;
System.out.println(""t6 BIRDS after="" + t6.cats);
}
}",MCQ,B,"t6 BIRDS before=25
t6 BIRDS after=25","t6 BIRDS before=25
t6 BIRDS after=10","t6 BIRDS before=25
t6 BIRDS after=0",Compile Time Error,"The static variable ""cats"" is common to all objects. There is no separate copy like non-static variables.",Classes and Objects
12/27/2020 19:50:06,Predict the output.,"public class Test
{
int cars = 20;
void change(final int cars)
{
cars = 10;
this.cars = cars;
}
public static void main(String[] args)
{
Test t8 = new Test();
t8.change(30);
System.out.println(t8.cars);
}
}",MCQ,D,30,20,10,Compiler Error,"The argument that is marked final can not be reassigned or changed. So, the compiler error is produced. So, the statement cars=10; inside the change() method is wrong.",Classes and Objects
12/27/2020 19:54:47,Predict the output.,"class Road {
static void show() {
System.out.println(""Inside static method."");
}
}

public class Test {
public static void main(String[] args) {
Road.show();
}
}",MCQ,A,Inside static method.,empty message,Compiler error (Road variable has not been initialized),Runtime error / exception,You can directly call static methods of a class with just a DOT operator and class-name.,Classes Methods
12/27/2020 20:12:03,Predict the output,"class SomeClass {
char batch = 'A';
}

public class Test {
public static void main(String[] args) {
SomeClass a1 = new SomeClass();
System.out.println(""Before: "" + a1.batch);
SomeClass a2 = new SomeClass();
a2.batch = 'B';
System.out.println(""After: "" + a1.batch);
}
}",MCQ,B,"Before: A
After: B","Before: A
After: A","Before: A
After: ","Before: B
After: B","Instance variable ""batch"" is separate for each instance. So the changes to one instance object does not affect another instance object.",Classes and Objects
12/27/2020 20:15:27,The purpose of a Java constructor is ___.,,MCQ,D,Initialization of variables with passed data,Writing custom code,Accepting other objects as inputs,All the above,,Constructor
12/27/2020 20:19:20,Predict the output,"public class Test{
void Test() {
System.out.println(""Amsterdam"");
}

Test() {
System.out.println(""Antarctica"");
}

public static void main(String[] args) {
Test tc = new Test();
}
}",MCQ,A,Antarctica,Amsterdam,No output,Compiler error,Constructors does not have return type. If we give return type to constructor then it acts like a method.,Constructor
12/27/2020 20:28:11,A constructor with no parameters or no arguments is called ___.,,MCQ,A,Default constructor,User-defined constructor,Method,Both A & B,"Default Constructor is a constructor that can be called without having to provide any arguments, irrespective of whether the constructor is auto-generated or user-defined.",Constructor
12/27/2020 20:30:12,A constructor with one or more arguments or parameters is called a ___ constructor.,,MCQ,D,Default constructor,User-defined constructor,Non-default constructor,Both B & C,,Constructor
12/27/2020 20:35:26,Predict the output.,"public class Test
{
int count=10;
Test(int count)
{
System.out.println(""Count="" + count);
}

public static void main(String[] args)
{
Test con = new Test();
}
}",MCQ,C,Count=0,Count=10,Compiler error,None of the above,"If you write a constructor with arguments, the default constructor is not added by the compiler. You should add it explicitly.",Constructor
12/27/2020 20:37:06,Predict the output,"public class Test {
int birds = 10;

Test() {
this(20);
}

Test(int birds) {
System.out.println(""Birds="" + birds);
}

public static void main(String[] args) {
Test con = new Test();
}
}",MCQ,C,Birds=0,Birds=10,Birds=20,Compiler error,You can pass parameters to another constructor.,Constructor
12/27/2020 20:38:50,You can pass __ variables from one constructor to another overloaded constructor.,,MCQ,D,local variables,static variables,non-static variables,Both A & B,,Constructor
12/27/2020 20:41:35,Predict the output.,"public class Test {
Test(int a) {
System.out.println(""Book="" + a);
}

Test(float a) {
System.out.println(""Pen="" + a);
}

public static void main(String[] args) {
Test con = new Test(50.5f);
}
}",MCQ,B,Book=50,Pen=50.5,Compiler error,None of the above,Constructor overloading allows constructors with different arguments at the same time.,Constructor
12/30/2020 16:18:22,Predict the output.,"public class Test {
Test(boolean a) {
System.out.println(""MODEM="" + a);
}

Test(float a) {
System.out.println(""ROUTER="" + a);
}

public static void main(String[] args) {
Test con1 = new Test(50);
Test con2 = new Test(false);
}
}",MCQ,A,"ROUTER=50.0
MODEM=false","ROUTER=50
MODEM=false",Compiler error,None,Java knows when to typecast a variable to a higher type like a float from int. So the number 50 is passed to a constructor accepting a float argument as there is no constructor accepting int argument above.,Constructor
12/30/2020 16:23:27,Choosing a suitable overloaded constructor happens at compile time in Java.,,True or False,FALSE,TRUE,FALSE,,,,Constructor
12/30/2020 16:24:44,Java constructor overloading follows ___ principle in Object-Oriented programming.,,MCQ,C,Inheritance,Encapsulation,Polymorphism,None,"Overloading of constructors requires you to specify the same name to all constructors. So, it satisfies the polymorphism principle of Oops.",Polymorphism
12/30/2020 16:27:07,Predict the output.,"public class Test {
Test() {
show();
}

void show() {
System.out.println(""JAM JAM"");
}

public static void main(String[] args) {
Test con = new Test();
}
}",MCQ,A,JAM JAM,No Output,Compile error,None,,Constructor
12/30/2020 16:32:21,"To successfully overload a method in Java, the return types must be ___.",,MCQ,C,Same,Different,Same but using superclass or subclass types also work,None,,Method Overloading
12/30/2020 16:33:13,"To successfully overload a method in Java, the argument-list or parameter-list must be same.",,True or False,FALSE,TRUE,FALSE,,,,Method Overloading
12/30/2020 16:44:43,Predict the output.,"public class Test {
void show(int a, char b) {
System.out.println(""KING KONG"");
}

void show(char a, int b) {
System.out.println(""JIM JAM"");
}

public static void main(String[] args) {
Test m = new Test();
m.show(10, 'A');
m.show('B', 10);
}
}",MCQ,C,"JIM JAM
JIM JAM","KING KONG
KING KONG","KING KONG
JIM JAM",compiler error,Method signatures are clearly different. So both methods work.,Method Overloading
12/30/2020 16:53:31,"To successfully overload a method in Java, the method names must be ___.",,MCQ,A,Same,Different,Same or different,None,,Method Overloading
12/30/2020 16:56:42,Predict the output.,"public class Test {
int info() {
System.out.println(""PLANE"");
return 0;
}

void info() {
System.out.println(""AIRPORT"");
}

public static void main(String[] args) {
Test m = new Test();
int a = m.info();
}
}",MCQ,C,PLANE,AIRPORT,Compiler error,None,"Both methods with the same name ""info"" do not overload successfully as the return types are different (void and int).",Method Overloading
12/30/2020 16:59:50,Predict the output.,"class Wood {
}

class SubWood extends Wood {
}

public class Test {
Wood display(int a) {
System.out.println(""PINE"");
return new Wood();
}

SubWood display() {
System.out.println(""TEAK"");
return new SubWood();
}

public static void main(String[] args) {
Test m = new Test();
m.display();
}
}",MCQ,B,PINE,TEAK,Compiler error,None,"Return types for the method display() are Wood and SubWood. As these types are of superclass-subclass, it is a valid method overloading.",Method Overloading
12/30/2020 17:05:15,Predict the output.,"class Rabbit {
}

class WildRabbit extends Rabbit {
}

public class Test {
Rabbit jump() {
System.out.println(""Rabbit Jump"");
return new Rabbit();
}

WildRabbit jump() {
System.out.println(""Wild Rabbit Jump"");
return new WildRabbit();
}

public static void main(String[] args) {
Test obj = new Test();
obj.jump();
}
}",MCQ,C,Rabbit Jump,Wild Rabbit Jump,Compiler error,None,"The above program does not overload the method jump() properly as the argument list is not distinct. So the compiler reports ""duplicate method error"".",Inheritance
12/30/2020 17:09:53,Java method overloading implements the OOPS concept ___.,,MCQ,B,Inheritance,Polymorphism,Encapsulation,None,,Method Overloading
12/30/2020 17:13:23,Predict the output,"public class Test {
static int abs(int a) {
return a < 0 ? -a : a;
}

static float abs(float b) {
return b < 0 ? -b : b;
}

static double abs(double c) {
return c < 0 ? -c : c;
}

public static void main(String[] args) {
int a = -10;
float b = -4.56f;
double c = -10.123;
System.out.println(Test.abs(a) + "", "" + Test.abs(b) + "", "" + Test.abs(c));
}
}",MCQ,C,No output,Compiler error,"10, 4.56, 10.123","-10, -4.56, -10.123","The above program demonstrates the usage of Overloaded methods. ""abs"" function returns the absolute value of the input.",Method Overloading
12/31/2020 19:07:13,Which of the following is a type of polymorphism in Java?,,MCQ,A,Compile time polymorphism,Execution time polymorphism,Multiple polymorphism,Multilevel polymorphism,There are two types of polymorphism in Java. Compile time polymorphism (overloading) and runtime polymorphism (overriding).,Polymorphism
12/31/2020 19:11:08,What is the return type of a method that does not return any value?,,MCQ,C,int,float,void,double,Return type of a method must be made void if it is not returning any value.,Classes Methods
12/31/2020 19:12:47,What is the process of defining more than one method in a class differentiated by method signature?,,MCQ,B,Method overriding,Method overloading,Method doubling,None of the mentioned,"Method overloading is a process of defining more than one method in a class with same name differentiated by method signature i:e return type or parameters type and number. Example – int volume(int length, int width) & int volume(int length , int width , int height) can be used to calculate volume.",Classes Methods
12/31/2020 19:13:39,Which of the following is a method having same name as that of it’s class?,,MCQ,D,finalize,delete,class,constructor,A constructor is a method that initializes an object immediately upon creation. It has the same name as that of class in which it resides.,Classes Methods
12/31/2020 19:15:06,Which method can be defined only once in a program?,,MCQ,A,main method,finalize method,static method,private method,main() method can be defined only once in a program. Program execution begins from the main() method by java runtime system.,Classes Methods
12/31/2020 19:16:24,Which of this statement is incorrect?,,MCQ,D,All object of a class are allotted memory for the all the variables defined in the class,If a function is defined public it can be accessed by object of other class by inheritation,main() method must be made public,All object of a class are allotted memory for the methods defined in the class,"All object of class share a single copy of methods defined in a class, Methods are allotted memory only once. All the objects of the class have access to methods of that class are allotted memory only for the variables not for the methods.",Classes Methods
12/31/2020 19:20:29,Predict the output,"class box {

int width;
int height;
int length;
int volume;

void volume(int height, int length, int width) {
volume = width * height * length;
}
}

class Test {
public static void main(String args[]) {

box obj = new box();
obj.height = 1;
obj.length = 5;
obj.width = 5;
obj.volume(3, 2, 1);

System.out.println(obj.volume);
}
}",MCQ,C,0,1,6,25,,Classes Methods
12/31/2020 19:22:33,Predict the output,"class equality {

int x;
int y;

boolean isequal() {
return (x == y);
}
}

class Test {

public static void main(String args[]) {

equality obj = new equality();
obj.x = 5;
obj.y = 5;

System.out.println(obj.isequal());
}
}",MCQ,B,FALSE,TRUE,0,1,,Classes Methods
12/31/2020 19:31:51,Predict the output,"class Test {

public static int sum(int... x) {
return x[0];
}

public static void main(String args[]) {

sum(10);
sum(10, 20);
sum(10, 20, 30);
sum(10, 20, 30, 40);

}

}",MCQ,D,only sum(10),"only sum(10,20)","only sum(10) & sum(10,20)",all of the mentioned,sum is a variable argument method and hence it can take any number as an argument.,Classes Methods
12/31/2020 19:33:56,Predict the output,"class area {

int width;
int length;
int volume;

area() {
width = 5;
length = 6;
}

void volume() {
volume = width * length * height;
}
}

class cons_method {

public static void main(String args[]) {

area obj = new area();
obj.volume();
System.out.println(obj.volume);

}
}",MCQ,D,0,1,30,error,Variable height is not defined.,Classes Methods
12/31/2020 19:40:40,What is true about private constructor?,,MCQ,A,Private constructor ensures only one instance of a class exist at any point of time,Private constructor ensures multiple instances of a class exist at any point of time,Private constructor eases the instantiation of a class,Private constructor allows creating objects in other classes,Object of private constructor can only be created within class. Private constructor is used in singleton pattern.,Constructor
12/31/2020 19:42:00,What is false about constructor?,,MCQ,C,Constructors cannot be synchronized in Java,Java does not provide default copy constructor,Constructor can have a return type,“this” and “super” can be used in a constructor,The constructor cannot have a return type. It should create and return new objects. Hence it would give a compilation error.,Constructor
12/31/2020 19:42:52,What is true about constructor?,,MCQ,B,It can contain return type,It can take any number of parameters,It can have any non access modifiers,Constructor cannot throw an exception,Constructor returns a new object with variables defined as in the class. Instance variables are newly created and only one copy of static variables are created.,Constructor
12/31/2020 19:44:23,What would be behaviour if the constructor has a return type?,,MCQ,A,Compilation error,Runtime error,Compilation and runs successfully,Only String return type is allowed,The constructor cannot have a return type. It should create and return new object. Hence it would give compilation error.,Constructor
12/31/2020 19:45:24,What is true about protected constructor?,,MCQ,B,Protected constructor can be called directly,Protected constructor can only be called using super(),Protected constructor can be used outside package,protected constructor can be instantiated even if child is in a different package,Protected access modifier means that constructor can be accessed by child classes of the parent class and classes in the same package.,Constructor
12/31/2020 20:08:09,What is the process of defining two or more methods within same class that have same name but different parameters declaration?,,MCQ,A,method overloading,method overriding,method hiding,none of the mentioned,"Two or more methods can have same name as long as their parameters declaration is different, the methods are said to be overloaded and process is called method overloading. Method overloading is a way by which Java implements polymorphism.",Method Overloading
12/31/2020 20:08:57,Which of these can be overloaded?,,MCQ,C,Methods,Constructors,All of the mentioned,None of the mentioned,,Method Overloading
12/31/2020 20:10:16,"What is the process of defining a method in terms of itself, that is a method that calls itself?",,MCQ,D,Polymorphism,Abstraction,Encapsulation,Recursion,,Classes Methods
12/31/2020 20:12:42,Predict the output,"class overload {

int x;
int y;

void add(int a) {
x = a + 1;
}

void add(int a, int b) {
x = a + 2;
}
}

class Test {

public static void main(String args[]) {

overload obj = new overload();
int a = 0;
obj.add(6);
System.out.println(obj.x);

}
}",MCQ,C,Compile Error,6,7,8,,Method Overloading
12/31/2020 20:29:39,Predict the output,"class overload {

int x;
double y;

void add(int a, int b) {
x = a + b;
}

void add(double c, double d) {
y = c + d;
}

overload() {
this.x = 0;
this.y = 0;
}
}

class Test {

public static void main(String args[]) {

overload obj = new overload();
int a = 2;
double b = 3.2;
obj.add(a, a);
obj.add(a, b);
System.out.println(obj.x + "" "" + obj.y);

}
}",MCQ,D,Compile error,Run time error,4 6.4,4 5.2,"There is no add method with arguments as (int, double). But java compiler uses type casting at runtime (converts int to float). ",Method Overloading
12/31/2020 20:32:37,Predict the output,"class output {

int a;
int b;

void meth(int i, int j) {

i *= 2;
j /= 2;

}
}

class Test {

public static void main(String args[]) {

output obj = new output();
int a = 10;
int b = 20;
obj.meth(a, b);
System.out.println(a + "" "" + b);

}
}",MCQ,A,10 20,20 10,20 40,40 20,"Variables a & b are passed by value, copy of their values are made on formal parameters of function meth() that is i & j. Therefore changes done on i & j are not reflected back on original arguments. a & b remain 10 & 20 respectively.",Method Overloading
12/31/2020 20:35:05,Predict the output,"class output 
{

int a;
int b;
output(int i, int j) {
a = i;
b = j;
}

void meth(output o) {
o.a *= 2;
o.b /= 2;
} 
} 

class Test {

public static void main(String args[]) {

output obj = new output(10 , 20);
obj.meth(obj);
System.out.println(obj.a + "" "" + obj.b); 

} 
}",MCQ,B,10 20,20 10,20 40,40 20,"Class objects are always passed by reference, therefore changes done are reflected back on original arguments. obj.meth(obj) sends object obj as parameter whose variables a & b are multiplied and divided by 2 respectively by meth() function of class test. a & b becomes 20 & 10 respectively.",Classes Methods
12/31/2020 21:48:30,What is the process of defining a method in a subclass having same name & type signature as a method in its superclass?,,MCQ,B,Method overloading,Method overriding,Method hiding,None of the mentioned,,Method Overriding
12/31/2020 21:49:24,Which of these keywords can be used to prevent Method overriding?,,MCQ,D,static,constant,protected,final,"To disallow a method from being overridden, specify final as a modifier at the start of its declaration. Methods declared as final cannot be overridden.",Method Overriding
12/31/2020 21:51:15,Which of these is supported by method overriding in Java?,,MCQ,C,Abstraction,Encapsulation,Polymorphism,None of the mentioned,,Method Overriding
12/31/2020 21:57:59,Predict the output,"final class A {
int i;
}

class B extends A {
int j;
System.out.println(j + "" "" + i); 
}

class Test {
public static void main(String args[]) {
B obj = new B();
obj.display();
}
}",MCQ,D,2 2,3 3,Runtime Error,Compilation Error,"class A has been declared final hence it cannot be inherited by any other class. Hence class B does not have member i, giving compilation error.",Inheritance
12/31/2020 22:01:04,Predict the output.,"class A {

int i;

public void display() {
System.out.println(i);
}
}

class B extends A {

int j;

public void display() {
System.out.println(j);
}
}

class Dynamic_dispatch {

public static void main(String args[]) {

B obj2 = new B();
obj2.i = 1;
obj2.j = 2;

A r;
r = obj2;
r.display();

}
}",MCQ,B,1,2,Compile time error,Runtime error,"This is example of runtime polymorphism. r is reference of type A, the program assigns a reference of object obj2 to r and uses that reference to call function display() of class B.",Polymorphism
12/31/2020 22:06:10,Which of this keyword must be used to inherit a class?,,MCQ,D,super,this,extent,extends,,Inheritance
12/31/2020 22:07:15,Which of these is correct way of inheriting class A by class B?,,MCQ,C,class B + class A {},class B inherits class A {},class B extends A {},class B extends class A {},,Inheritance
12/31/2020 22:12:20,Predict the output,"class A {
int i;

void display() {
System.out.println(i);
}
}

class B extends A {
int j;

void display() {
System.out.println(j);
}
}

class Test {

public static void main(String args[]) {

B obj = new B();
obj.i = 1;
obj.j = 2;
obj.display();

}
}",MCQ,C,0,1,2,Compilation Error,"Class A & class B both contain display() method, class B inherits class A, when display() method is called by object of class B, display() method of class B is executed rather than that of Class A.",Inheritance
12/31/2020 22:21:37,Predict the output,"class A {
int i;
}

class B extends A {

int j;

void display() {
super.i = j + 1;
System.out.println(j + "" "" + i);
}
}

class inheritance {

public static void main(String args[]) {

B obj = new B();
obj.i = 1;
obj.j = 2;
obj.display();
}
}",MCQ,C,2 2,3 3,2 3,3 2,,Inheritance
12/31/2020 22:24:58,Predict the output.,"class A {

public int i;
public int j;

A() {
i = 1;
j = 2;
}
} 

class B extends A {

int a;

B() {
super();
} 
} 

class Test {

public static void main(String args[]){
B obj = new B();
System.out.println(obj.i + "" "" + obj.j);
}
}",MCQ,A,1 2,2 1,Runtime Error,Compilation Error,Keyword super is used to call constructor of class A by constructor of class B. Constructor of a initializes i & j to 1 & 2 respectively.,Inheritance
12/31/2020 22:28:40,What is not type of inheritance?,,MCQ,B,Single inheritance,Double inheritance,Hierarchical inheritance,Multiple inheritance,Inheritance is way of acquiring attributes and methods of parent class. Java supports hierarchical inheritance directly.,Inheritance
12/31/2020 22:52:01,"Using which of the following, multiple inheritance in Java can be implemented?",,MCQ,A,Interfaces,Multithreading,Protected methods,Private methods,This is also known as Double Diamond Problem. We can't implement multiple inheritance in java (without inter),Inheritance
12/31/2020 22:53:51,What would be the result if a class extends two interfaces and both have a method with same name and signature? Lets assume that the class is not implementing that method.,,MCQ,B,Runtime error,Compile time error,Code runs successfully,First called method is executed successfully,"In case of such conflict, compiler will not be able to link a method call due to ambiguity. It will throw compile time error.",Inheritance
12/31/2020 22:55:03,Static members are not inherited to subclass.,,True or False,FALSE,TRUE,FALSE,,,,Inheritance
12/31/2020 22:55:44,"In order to restrict a variable of a class from inheriting to subclass, how variable should be declared?",,MCQ,B,Protected,Private,Public,Static,"By declaring variable private, the variable will not be available in inherited to subclass.",Inheritance
